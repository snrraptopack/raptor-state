function e(e,t){for(const r in e)t(e[r],r)}function t(e,t){e.forEach(t)}function r(e,t,r){if(!e)throw Error(`${r?r+': ':''}${t}`)}function n(e,t){const r=_(e),n=r.meta||{};re(e)||(n.isRegion=1),ye={id:r.id,parent:ye,value:e,template:n.template||be(),sidRoot:n.sidRoot||ye&&ye.sidRoot,meta:n};try{return t()}finally{ve('region'),ye=H(ye)}}function a({node:e=[],from:r,source:n,parent:a=r||n,to:o,target:s,child:i=o||s,scope:c={},meta:l={},family:d={type:'regular'},regional:u}={}){const f=$e(a),p=$e(d.links),m=$e(d.owners),g=[];t(e,(e=>e&&ie(g,e)));const h={id:pe(),seq:g,next:$e(i),meta:l,scope:c,family:{triggers:f.length,type:d.type||"crosslink",links:p,owners:m}};return t(p,(e=>ie(V(e),h))),t(m,(e=>ie(L(e),h))),t(f,(e=>ie(e.next,h))),u&&ye&&we(W(ye),[h]),h}function o(e,r,n){let a,o=ot,s=null,i=tt;if(e.target&&(r=e.params,n=e.defer,a=e.meta,o='page'in e?e.page:o,e.stack&&(s=e.stack),i=U(e)||i,e=e.target),i&&tt&&i!==tt&&(tt=null),Array.isArray(e))for(let t=0;t<e.length;t++)Xe('pure',o,_(e[t]),s,r[t],i,a);else Xe('pure',o,_(e),s,r,i,a);if(n&&!rt)return;const c={isRoot:rt,currentPage:ot,scope:tt,isWatch:nt,isPure:at};let l,d,u,f,p,m;rt=0;e:for(;f=Qe();){const{idx:e,stack:r,type:n}=f;u=r.node,ot=p=r.page,tt=U(r),p?m=p.reg:tt&&(m=tt.reg);const a=!!p,o=!!tt,s={fail:0,scope:u.scope};l=d=0;for(let t=e;t<u.seq.length&&!l;t++){const i=u.seq[t];if(i.order){const{priority:a,barrierID:o}=i.order,s=o?p?`${p.fullID}_${o}`:o:0;if(t!==e||n!==a){o?et.has(s)||(et.add(s),Ye(t,r,a,o)):Ye(t,r,a,0);continue e}o&&et.delete(s)}switch(i.type){case'mov':{const e=i.data;let t;switch(e.from){case'stack':t=W(r);break;case'a':case'b':t=r[e.from];break;case'value':t=e.store;break;case'store':if(m&&!m[e.store.id])if(a){const t=lt(p,e.store.id);r.page=p=t,t?m=t.reg:o?(mt(tt,e.store,0,1,e.softRead),m=tt.reg):m=void 0}else o&&mt(tt,e.store,0,1,e.softRead);t=We(m&&m[e.store.id]||e.store)}switch(e.to){case'stack':r.value=t;break;case'a':case'b':r[e.to]=t;break;case'store':dt(p,tt,e.target,0).current=t}break}case'compute':const e=i.data;if(e.fn){nt='watch'===u.meta.op,at=e.pure;const t=e.safe?(0,e.fn)(W(r),s.scope,r):gt(s,e.fn,r);e.filter?d=!t:r.value=t,nt=c.isWatch,at=c.isPure}}l=s.fail||d}if(ut&&ut(r,s),!l){const e=W(r),n=U(r);if(t(u.next,(t=>{Xe('child',p,t,r,e,n)})),n){u.meta.needFxCounter&&Xe('child',p,n.fxCount,r,e,n),u.meta.storeChange&&Xe('child',p,n.storeChange,r,e,n),u.meta.warnSerialize&&Xe('child',p,n.warnSerializeNode,r,e,n);const a=n.additionalLinks[u.id];a&&t(a,(t=>{Xe('child',p,t,r,e,n)}))}}}rt=c.isRoot,ot=c.currentPage,tt=U(c)}function s(t,r="combine"){let n=r+'(',a='',o=0;return e(t,(e=>{o<25&&(null!=e&&(n+=a,n+=Q(e)?K(e).fullName:e.toString()),o+=1,a=', ')})),n+')'}function i(e,t){e.shortName=t,Object.assign(K(e),c(t,H(e)))}function c(e,t){let r,n;const a=e;if(t){const a=K(t);0===e.length?(r=a.path,n=a.fullName):(r=a.path.concat([e]),n=0===a.fullName.length?e:a.fullName+'/'+e)}else r=0===e.length?[]:[e],n=e;return{shortName:a,fullName:n,path:r}}function l(e,t){if(!t)return e;if(!t.name&&!t.named&&!t.loc)return e;let r=`[${e}]`;const n=t.named||t.name;n&&(r+=` unit '${n}'`);const a=t.loc;return!n&&a&&(r+=` (${a.file}:${a.line}:${a.column})`),r}function d(e,t){const r=t?e:e[0];Re(r);let n=r.or;const a=r.and;if(a){const r=t?a:a[0];if(Me(r)&&'and'in r){const r=d(a,t);e=r[0],n={...n,...r[1]}}else e=a}return[e,n]}function u(e){const t=()=>e();return t.unsubscribe=()=>e(),t}function f(e,...t){const r=be();if(r){const n=r.handlers[e];if(n)return n(r,...t)}}function p(e,t){const n=ht({or:t,and:'string'==typeof e?{name:e}:e}),s=l('event',n),i=(e,...t)=>(r(!G(i,'derived'),'call of derived event is not supported, use createEvent instead',s),r(!at,'unit call from pure function is not supported, use operators like sample instead',s),ot?((e,t,r,n)=>{const a=ot;let o=null;if(t)for(o=ot;o&&o.template!==t;)o=H(o);ct(o);const s=e.create(r,n);return ct(a),s})(i,c,e,t):i.create(e,t)),c=be(),d=Object.assign(i,{graphite:a({meta:jt(n.actualOp||"event",i,n,At(p)),regional:1}),create:e=>(o({target:i,params:e,scope:tt}),e),watch:e=>xt(i,e),map:e=>Ct(i,P,e,[Ve()]),filter:e=>Ct(i,'filter',e.fn?e:e.fn,[Ve(Oe,1)]),filterMap:e=>Ct(i,'filterMap',e,[Ve(),Pe((e=>!ze(e)),1)]),prepend(e){r(i.targetable,'.prepend of derived event is not supported, call source event instead',s);const t=p('* \u2192 '+i.shortName,{parent:H(i)});return f('eventPrepend',_(t)),$t(t,i,[Ve()],'prepend',e),zt(i,t),t}});return null!=n&&n.domain&&n.domain.hooks.event(d),J(d,'id',d.graphite.id),ve(d.graphite),d}function m(e,n,a,o,s){return je(a,`${s} ${n}`,'first argument'),r(xe(o),'second argument should be a function',s),ce(!G(e,'derived'),`${n} in derived store`,`${n} in store created via createStore`,s),t(Array.isArray(a)?a:[a],(t=>{e.off(t),It(t,e,'on',Ie,o)})),e}function g(e,n){const s=ht(n),i=Be(e),c=l('store',s),d=p({named:'updates',derived:1});f('storeBase',i);const u=i.id,h='skipVoid'in s,y=h&&!s.skipVoid;ce(!(h&&s.skipVoid),'{skipVoid: true}','updateFilter',c);const v={updates:d,defaultState:e,stateRef:i,getState(){let e,t=i;if(ot){let t=ot;for(;t&&!t.reg[u];)t=H(t);t&&(e=t)}return!e&&tt&&(mt(tt,i,1),e=tt),e&&(t=e.reg[u]),We(t)},setState:e=>o({target:v,params:e,defer:1,scope:tt}),reset:(...e)=>(r(v.targetable,'.reset of derived store is not supported',c),t(e,(e=>m(v,'.reset',e,(()=>v.defaultState),c))),v),on:(e,t)=>(r(v.targetable,'.on of derived store is not supported',c),m(v,'.on',e,t,c)),off(e){const t=_(e).id,r=_(v).family.links.find((e=>e.meta.onTrigger===t));return r&&St(r),v},map(e,t){let r,n;Me(e)&&(r=e,e=e.fn);const a=v.getState(),o=ze(a);be()?n=null:(!o||o&&y)&&(n=e(a));const s=g(n,{name:`${v.shortName} \u2192 *`,derived:1,...t,and:r}),c=It(v,s,P,Oe,e);return He(B(s),{type:P,fn:e,from:i}),B(s).noInit=1,f('storeMap',i,c),s},watch(e,t){if(ce(!t,'watch second argument','sample',c),!t||!Q(e)){const t=xt(v,e);return f('storeWatch',i,e)||e(v.getState()),t}return r(xe(t),'second argument should be a function',c),e.watch((e=>t(v.getState(),e)))}},b=jt("store",v,s,At(g)),k=v.defaultConfig.updateFilter;v.graphite=a({scope:{state:i,fn:k},node:[Pe(((e,t,r)=>(r.scope&&!r.scope.reg[i.id]&&(r.b=1),e))),_e(i),Pe(((e,t,{a:r,b:n})=>{const a=ze(e);return a&&!h&&le(`${c}: ${Nt}`,G(v,'unitTrace')),(a&&y||!a)&&(e!==r||n)}),1),k&&Ve(Ne,1),De({from:"stack",target:i})],child:d,meta:{...b,defaultState:e,stateRef:i},regional:1}),J(v,'id',v.graphite.id),J(v,'rootStateRefId',u);const S=G(v,'serialize'),w=G(v,'derived'),$='ignore'===S,M=G(v,'sid');M&&(J(v,'storeChange',1),i.sid=M),M||$||w||J(v,'warnSerialize',1);const x=ze(e);return r(w||!x||x&&y,Nt,c),w&&x&&!h&&console.error(`${c}: ${Nt}`),we(v,[d]),null!=s&&s.domain&&s.domain.hooks.store(v),w||(v.reinit=p({named:'reinit'}),v.reset(v.reinit)),i.meta=v.graphite.meta,ve(v.graphite),v}function h(...e){let t,n,a;[e,a]=d(e);const o=l('combine',a),s=e[e.length-1],i=e.length>1&&!Y(s)&&Me(s),c=i&&s,u=i?e[e.length-2]:s;let f,p,m;if(xe(u)?(n=e.slice(0,i?-2:-1),t=u):n=e,1===n.length){const e=n[0];Y(e)||(f=e,p=1)}if(!p&&(f=n,t)){m=1;const e=t;t=t=>e(...t)}return r(Me(f),`${o}: shape should be an object`),Ot(Array.isArray(f),!m,f,At(h),a,t,c)}function y(){const e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function v(e,t={}){const n=ht(xe(e)?{handler:e}:e,t),s=l('effect',n),i=p(xe(e)?{handler:e}:e,{...t,actualOp:"effect"});Rt(i,At(v));const c=_(i);J(c,'op',i.kind="effect"),i.use=e=>(r(xe(e),'.use argument should be a function',s),b.scope.handler=e,i),i.use.getCurrent=()=>b.scope.handler;const d=i.finally=p({named:'finally',derived:1}),u=i.done=d.filterMap({named:'done',fn({status:e,params:t,result:r}){if('done'===e)return{params:t,result:r}}}),f=i.fail=d.filterMap({named:'fail',fn({status:e,params:t,error:r}){if('fail'===e)return{params:t,error:r}}}),m=i.doneData=u.map({named:'doneData',fn:({result:e})=>e}),h=i.failData=f.map({named:'failData',fn:({error:e})=>e}),b=a({scope:{handler:i.defaultConfig.handler||(()=>r(0,`no handler used in ${i.compositeName.fullName}`))},node:[Pe(((e,t,r)=>{let n=t.handler;const a=U(r);if(a){const e=a.handlers.unitMap.get(i)||a.handlers.sidMap[i.sid];e&&(n=e)}return e.handler=n,e}),0,1),Pe(((e,t,r)=>{if(t.runnerFn&&!t.runnerFn(e,null,r))return;const{params:n,req:a,handler:o,args:s=[n]}=e,i=qt(n,a,1,d,r),c=qt(n,a,0,d,r),[l,u]=Ft(o,c,s);l&&(Me(u)&&xe(u.then)?u.then(i,c):i(u))}),0,1)],meta:{op:'fx',fx:'runner'},regional:1});c.scope.runner=b,ie(c.seq,Pe(((e,{runner:t},r)=>{const n=H(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return r.meta||(r.meta={fxID:me()}),o({target:t,params:n,defer:1,scope:U(r),meta:r.meta}),n.params}))),i.create=e=>{const t=y(),r={params:e,req:t};if(tt&&!nt){const e=tt;t.req.finally((()=>{st(e)})).catch((()=>{}))}return o({target:i,params:r,scope:tt}),t.req};const k=i.inFlight=g(0,{serialize:'ignore',named:(G(i,'name')||i.graphite.id)+'.inFlight'}).on(i,(e=>e+1)).on(d,(e=>e-1)).map({fn:e=>e,named:'inFlight'});J(d,'needFxCounter','dec'),J(i,'needFxCounter',1);const S=i.pending=k.map({fn:e=>e>0,named:'pending'});return we(i,[d,u,f,m,h,S,k]),null!=n&&n.domain&&n.domain.hooks.effect(i),i}function b(e){let t;[e,t]=d(e,1);const n=l('attach',t);let{source:a,effect:s,mapParams:i,domain:u}=e;ee(s)&&r(ze(u),'`domain` can only be used with a plain function',n);const f=v(e,t);J(f,'attached',1),Rt(f,At(b));const{runner:p}=_(f).scope;let m;const g=(e,t,r)=>{const{params:n,req:s,handler:c}=e,l=f.finally,d=qt(n,s,0,l,r),u=r.a,p=ee(c);let m,g=1;if(i?[g,m]=Ft(i,d,[n,u]):m=a&&p?u:n,g){if(!p)return e.args=[u,m],1;o({target:c,params:{params:m,req:{rs:qt(n,s,1,l,r),rj:d}},page:r.page,defer:1,meta:r.meta})}};if(a){let e;p.scope.runnerFn=g,Y(a)?(e=a,we(e,[f])):(e=h(a),we(f,[e])),m=[Pe((e=>e),0,1),_e(B(e))],delete p.seq[1].order}else m=[Pe(g,1,1)];p.seq.splice(1,0,...m),f.use(s);const y=H(s);return y&&(Object.assign(K(f),c(f.shortName,y)),f.defaultConfig.parent=y),zt(s,f,"effect"),f}function k(...t){let[[r,n],a]=d(t);const o={};return e(n,((e,t)=>{const n=o[t]=p(t,{parent:H(r),config:a});r.on(n,e),zt(r,n)})),o}function S(r,n){const s=ht({or:n,and:'string'==typeof r?{name:r}:r}),i=a({family:{type:"domain"},regional:1,parent:(null==s?void 0:s.domain)||(null==s?void 0:s.parent)}),c={history:{},graphite:i,hooks:{}};i.meta=jt("domain",c,{parent:(null==s?void 0:s.domain)||(null==s?void 0:s.parent),or:{...s,derived:1}},At(S)),e({Event:p,Effect:v,Store:g,Domain:S},((e,r)=>{const n=r.toLowerCase(),a=p({named:`on${r}`});c.hooks[n]=a;const s=new Set;c.history[`${n}s`]=s,a.create=e=>(o(a,e),e),ie(_(a).seq,Pe(((e,t,r)=>(r.scope=null,e)))),a.watch((e=>{we(c,[e]),s.add(e),e.ownerSet||(e.ownerSet=s),H(e)||(e.parent=c)})),we(c,[a]),c[`onCreate${r}`]=e=>(t(s,e),a.watch(e)),c[`create${r}`]=c[n]=(t,r)=>{const n=ht({and:r,or:t});return null!=n&&n.domain?e(t,r):a(e(t,{parent:c,or:n}))}}));const l=H(c);return l&&e(c.hooks,((e,t)=>$t(e,l.hooks[t]))),null!=s&&s.domain&&s.domain.hooks.domain(c),c}function w(e){Re(e);const t=E in e?e[E]():e;r(t.subscribe,'expect observable to have .subscribe');const n=p(),a=wt(n);return t.subscribe({next:n,error:a,complete:a}),n}function $(e,n){let a=0;return t(Tt,(t=>{t in e&&(r(null!=e[t],Et(n,t)),a=1)})),a}function M(...e){let t,r,n,a,[[o,s,i],c]=d(e),u=1;const f=l('sample',c);return ze(s)&&Me(o)&&$(o,f)&&(s=o.clock,i=o.fn,'batch'in o?u=o.batch:(ce(!('greedy'in o),'greedy in sample','batch',f),u=!o.greedy),a=o.filter,t=o.target,r=o.name,n=o.sid,o=o.source),Pt('sample',s,o,a,t,i,r,c,u,1,0,n)}function x(...e){let[[t,r],n]=d(e);const a=l('guard',n);return ce(0,'guard','sample',a),r||(r=t,t=r.source),$(r,a),Pt('guard',r.clock,t,r.filter,r.target,null,r.name,n,!r.greedy,0,1)}function z(e,t){const r=l('merge',t);je(e,r,'first argument');const n=p({name:s(e,'merge'),derived:1,and:t});return $t(e,n,[],'merge'),n}function R(t,n,a){const o=l('restore',a);if(r(!Y(t),'restore($store) is not supported',o),Z(t)||ee(t)){const e=H(t),r=g(n,{parent:e,name:t.shortName,and:a});return $t(ee(t)?t.doneData:t,r),e&&e.hooks.store(r),r}const s=Array.isArray(t)?[]:{};return e(t,((e,t)=>s[t]=Y(e)?e:g(e,{name:t}))),s}function A(...t){const n='split';let o,s,[[i,c],u]=d(t);const m=l(n,u),g=!c;g&&(o=i.cases,c=i.match,s=i.clock,i=i.source);const h=Y(c),y=!Q(c)&&xe(c),v=!h&&!y&&Me(c);r(Q(i),'source must be a unit',m),o||(o={}),g?e(o,((e,t)=>Ce(m,e,`cases.${t}`))):(r(v,'match should be an object',m),e(c,((e,t)=>o[t]=p({derived:1,named:`cases.${t}`,and:u}))),o.__=p({derived:1,named:'cases.__',and:u}));const b=new Set([].concat(i,s||[],Object.values(o))),k=Object.keys(h||y?o:c);let S,w;if(h||y)h&&b.add(c),S=[h&&_e(B(c),0,1),Te({safe:h,filter:1,pure:!h,fn(e,t,r){const n=String(h?r.a:c(e));Lt(t,oe(k,n)?n:'__',e,r)}})];else if(v){const t=w=Be({});t.type='shape';const r=[];let n;e(c,((e,a)=>{if(Q(e)){n=1,ie(r,a),b.add(e);const o=$t(e,[],[_e(t),Pe(((e,t,{a:r})=>r[a]=e))]);if(Y(e)){t.current[a]=e.getState();const r=B(e);He(t,{from:r,field:a,type:'field'}),f('splitMatchStore',r,o)}}})),n&&f('splitBase',t),S=[n&&_e(t,0,1),Ve(((e,t,n)=>{for(let a=0;a<k.length;a++){const o=k[a];if(oe(r,o)?n.a[o]:c[o](e))return void Lt(t,o,e,n)}Lt(t,'__',e,n)}),1)]}else r(0,'expect match to be unit, function or object');const $=a({meta:{op:n,stateRef:w},parent:s?[]:i,scope:o,node:S,family:{owners:Array.from(b)},regional:1});if(s&&Pt(n,s,i,null,$,null,n,u,0,0,0),Rt($,At(A)),!g)return o}function j(e,{scope:t,params:r}={}){if(!Q(e))return Promise.reject(new Error('first argument should be unit'));if(!(ee(e)||Z(e)||Y(e)||ne(e)))return Promise.reject(new Error('first argument accepts only effects, events, stores or scopes'));if(ne(e))t=e;else if(!te(e)){const t=l('allSettled',_(e).meta);return Promise.reject(Error(`${t}: unit should be targetable`))}const n=y();n.parentFork=tt;const{fxCount:a}=t;ie(a.scope.defers,n);const s=[],i=[];return ne(e)||(ie(s,e),ie(i,ee(e)?{params:r,req:{rs(e){n.value={status:'done',value:e}},rj(e){n.value={status:'fail',value:e}}}}:r)),ie(s,a),ie(i,null),o({target:s,params:i,scope:t}),n.req}function C(e,r,n){const a=[];(function e(o){oe(a,o)||(ie(a,o),"store"===G(o,'op')&&(n||G(o,'sid'))&&r(o,G(o,'sid')),t(o.next,e),t(V(o),e),t(L(o),e))})(e)}function N(e,n){const a=Array.isArray(e)?new Map(e):e,o=new Map;let s=0;if(a instanceof Map){const e={};return t(a,((t,a)=>{r(Q(a),'Map key should be a unit'),n&&n(a,t),a.sid&&(a.sid in e&&(s=1),e[a.sid]=t),o.set(a,t)})),{sidMap:e,unitMap:o,hasSidDoubles:s}}return{sidMap:a,unitMap:o}}function I(e,n){let o,s=e;re(e)&&(ce(0,'fork(domain)','fork()'),o=e,s=n);const i=(e=>{const r=a({scope:{defers:[],inFlight:0,fxID:0},node:[Pe(((e,t,r)=>{r.parent?'dec'===r.parent.node.meta.needFxCounter?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),Te({priority:"sampler",batch:1}),Pe(((e,r)=>{const{defers:n,fxID:a}=r;r.inFlight>0||0===n.length||Promise.resolve().then((()=>{r.fxID===a&&t(n.splice(0,n.length),(e=>{st(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),n=a({node:[Pe(((e,t,r)=>{const n=r.parent;if(n){const t=n.node;if(Wt(n)){const n=U(r),a=t.meta.sid;n.sidIdMap[a]=t.scope.state.id,n.values.sidMap[a]=e;const o=t.meta.serialize;o&&n.sidSerializeSettings.set(a,'ignore'===o?{ignore:1}:{ignore:0,write:o.write})}}}))]}),o=a({node:[Pe(((e,t,r)=>{const n=U(r),a=r.parent;n&&a&&Wt(a)&&n.warnSerializeTraces.add(G(a.node,'unitTrace'))}))]}),s={cloneOf:e,reg:{},values:{sidMap:{},idMap:{}},sidIdMap:{},sidSerializeSettings:new Map,getState(e){if('current'in e)return dt(ot,s,e,0).current;const t=_(e);return dt(ot,s,t.scope.state,1).current},kind:"scope",graphite:a({family:{type:"domain",links:[r,n,o]},meta:{unit:'fork'},scope:{forkInFlightCounter:r}}),additionalLinks:{},handlers:{sidMap:{},unitMap:new Map},fxCount:r,storeChange:n,warnSerializeTraces:new Set,warnSerializeNode:o};return s})(o);if(s){if(s.values){const{sidMap:e,unitMap:n,hasSidDoubles:a}=N(s.values,(e=>r(Y(e)&&te(e),'Values map can contain only writable stores as keys')));Object.assign(i.values.sidMap,e),t(n,((e,t)=>{if(i.values.idMap[t.stateRef.id]=e,i.sidIdMap[G(t,'sid')]=t.stateRef.id,'ignore'===G(t,'serialize')){const e=G(t,'sid');i.sidSerializeSettings.set(e,{ignore:1})}})),i.fromSerialize=!(Array.isArray(s.values)||s.values instanceof Map),i.hasSidDoubles=a}s.handlers&&(ce(s.handlers instanceof Map||Array.isArray(s.handlers),'object with handlers','array'),i.handlers=N(s.handlers,(e=>r(ee(e),"Handlers map can contain only effects as keys"))))}return i}function O(e,{values:n}){r(Me(n),'values property should be an object');const{sidMap:a,unitMap:s}=N(n),i=Object.getOwnPropertyNames(a),c={};t(s,((e,t)=>{c[t.stateRef.id]=t}));const l=[],d=[];let u,f,p;ne(e)?(u=e,p=1,r(u.cloneOf,'scope should be created from domain'),ce(0,'hydrate(fork(domain), { values })','fork({ values })'),f=_(u.cloneOf)):re(e)?(ce(0,'hydrate(domain, { values })','fork({ values })'),f=_(e)):r(0,'first argument of hydrate should be domain or scope'),C(f,((e,t)=>{if(t&&oe(i,t)){ie(l,e);const r=G(e,'serialize');r&&'ignore'!==r&&(a[t]=r.read(a[t])),ie(d,a[t])}else e.scope.state.id in c&&(ie(l,e),ie(d,s.get(c[e.scope.state.id])))}),1),o({target:l,params:d,scope:u}),p&&Object.assign(u.values.sidMap,a)}function F(e,{scope:t,safe:n}={}){r(t||tt||n,'scopeBind: scope not found');const a=t||tt;return(...t)=>{function r(){st(s)}let n,o=0;const s=tt;st(a);try{n=e(...t)}catch(e){n=e,o=1}if(r(),o)throw n;return n instanceof Promise&&n.then(r,r),n}}function q(n,a={}){n.warnSerializeTraces.size&&(console.error('serialize: One or more stores dont have sids, their values are omitted'),t(n.warnSerializeTraces,(e=>{le('store should have sid or `serialize: ignore`',e)}))),r(!n.hasSidDoubles,'duplicate sid found in this scope');const o=a.ignore?a.ignore.map((({sid:e})=>e)):[],s={};return e(n.values.sidMap,((e,t)=>{var r;if(oe(o,t))return;const a=n.sidIdMap[t],i=null!==(r=n.sidSerializeSettings.get(t))&&void 0!==r?r:{ignore:0,write:Ht};i.ignore||(s[t]=(0,i.write)(a&&a in n.reg?n.reg[a].current:e))})),'onlyChanges'in a&&(ce(0,'onlyChanges'),a.onlyChanges||(r(n.cloneOf,'scope should be created from domain'),C(_(n.cloneOf),((e,t)=>{t in s||oe(o,t)||G(e,'isCombine')||'ignore'===G(e,'serialize')||(s[t]=n.getState(e))})))),s}function D({unit:e,fn:t,scope:r,batch:n}){const o=[Le.run({fn:e=>t(e)})];n&&o.unshift(Le.compute({priority:'sampler',batch:1})),Y(e)&&o.unshift(Le.mov({store:e.stateRef,to:'stack'}));const s=Array.isArray(e)?e:[e];if(r){const e=[],t=r.additionalLinks;return s.forEach((r=>{const n=t[r.graphite.id]||[];t[r.graphite.id]=n;const s=a({node:T(o,r),meta:{watchOp:r.kind}});n.push(s),e.push((()=>{const e=n.indexOf(s);-1!==e&&n.splice(e,1),St(s)}))})),u((()=>{e.forEach((e=>e()))}))}{const e=a({node:o,parent:s,family:{owners:s}});return u((()=>{St(e)}))}}function T(e,t){return Y(t)?[Le.mov({store:t.stateRef,to:'stack'}),...e]:e}const E='undefined'!=typeof Symbol&&Symbol.observable||'@@observable',P='map',_=e=>e.graphite||e,V=e=>e.family.owners,L=e=>e.family.links,B=e=>e.stateRef,W=e=>e.value,H=e=>e.parent,U=e=>e.scope,G=(e,t)=>_(e).meta[t],J=(e,t,r)=>_(e).meta[t]=r,K=e=>e.compositeName,Q=e=>(xe(e)||Me(e))&&'kind'in e,X=e=>t=>Q(t)&&t.kind===e,Y=X("store"),Z=X("event"),ee=X("effect"),te=e=>Q(e)&&!!e.targetable,re=X("domain"),ne=X("scope");var ae={__proto__:null,unit:Q,store:Y,event:Z,effect:ee,targetable:te,domain:re,scope:ne,attached:e=>ee(e)&&1==G(e,'attached')};const oe=(e,t)=>e.includes(t),se=(e,t)=>{const r=e.indexOf(t);-1!==r&&e.splice(r,1)},ie=(e,t)=>e.push(t),ce=(e,t,r,n)=>!e&&console.error(`${n?n+': ':''}${t} is deprecated${r?`, use ${r} instead`:''}`),le=(e,t)=>{const r=Error(e);r.stack=t,console.error(r)},de=()=>{let e=0;return()=>""+ ++e},ue=de(),fe=de(),pe=de(),me=de();let ge;const he=e=>{ge=e};let ye=null;const ve=e=>{ge&&ge(e,ye)},be=()=>ye&&ye.template,ke=e=>(e&&ye&&ye.sidRoot&&(e=`${ye.sidRoot}|${e}`),e),Se=({sid:e,name:t,loc:r,method:o,fn:s})=>n(a({meta:{sidRoot:ke(e),sid:e,name:t,loc:r,method:o,type:'factory'},regional:1}),s),we=(e,r)=>{const n=_(e);t(r,(e=>{const t=_(e);"domain"!==n.family.type&&(t.family.type="crosslink"),ie(V(t),n),ie(L(n),t)}))},$e=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(_),Me=e=>'object'==typeof e&&null!==e,xe=e=>'function'==typeof e,ze=e=>void 0===e,Re=e=>r(Me(e)||xe(e),'expect first argument be an object'),Ae=(e,t,n,a)=>r(!(!Me(e)&&!xe(e)||!('family'in e)&&!('graphite'in e)),`${t}: expect ${n} to be a unit (store, event or effect)${a}`),je=(e,r,n)=>{Array.isArray(e)?t(e,((e,t)=>Ae(e,r,`${t} item of ${n}`,''))):Ae(e,r,n,' or array of units')},Ce=(e,n,a="target")=>t($e(n),(t=>r(!G(t,'derived'),`${e}: derived unit in "${a}" is not supported, use createStore/createEvent instead"`))),Ne=(e,{fn:t},{a:r})=>t(e,r),Ie=(e,{fn:t},{a:r})=>t(r,e),Oe=(e,{fn:t})=>t(e),Fe=(e,t,r,n)=>{const a={id:fe(),type:e,data:t};return r&&(a.order={priority:r},n&&(a.order.barrierID=++qe)),a};let qe=0;const De=({from:e="store",store:t,target:r,to:n=(r?"store":"stack"),batch:a,priority:o})=>Fe('mov',{from:e,store:t,to:n,target:r},o,a),Te=({fn:e,batch:t,priority:r,safe:n=0,filter:a=0,pure:o=0})=>Fe('compute',{fn:e,safe:n,filter:a,pure:o},r,t),Ee=({fn:e})=>Te({fn:e,priority:"effect"}),Pe=(e,t,r)=>Te({fn:e,safe:1,filter:t,priority:r&&"effect"}),_e=(e,t,r)=>De({store:e,to:t?"stack":"a",priority:r&&"sampler",batch:1}),Ve=(e=Oe,t)=>Te({fn:e,pure:1,filter:t}),Le={mov:De,compute:Te,filter:({fn:e,pure:t})=>Te({fn:e,filter:1,pure:t}),run:Ee},Be=e=>({id:fe(),current:e,initial:e}),We=({current:e})=>e,He=(e,t)=>{e.before||(e.before=[]),ie(e.before,t)};let Ue=null;const Ge=(e,t)=>{if(!e)return t;if(!t)return e;let r;return(e.v.type===t.v.type&&e.v.id>t.v.id||Ze(e.v.type)>Ze(t.v.type))&&(r=e,e=t,t=r),r=Ge(e.r,t),e.r=e.l,e.l=r,e},Je=[];let Ke=0;for(;Ke<6;)ie(Je,{first:null,last:null,size:0}),Ke+=1;const Qe=()=>{for(let e=0;e<6;e++){const t=Je[e];if(t.size>0){if(3===e||4===e){t.size-=1;const e=Ue.v;return Ue=Ge(Ue.l,Ue.r),e}1===t.size&&(t.last=null);const r=t.first;return t.first=r.r,t.size-=1,r.v}}},Xe=(e,t,r,n,a,o,s)=>Ye(0,{a:null,b:null,node:r,parent:n,value:a,page:t,scope:o,meta:s},e,0),Ye=(e,t,r,n)=>{const a=Ze(r),o=Je[a],s={v:{idx:e,stack:t,type:r,id:n},l:null,r:null};3===a||4===a?Ue=Ge(Ue,s):(0===o.size?o.first=s:o.last.r=s,o.last=s),o.size+=1},Ze=e=>{switch(e){case'child':return 0;case'pure':return 1;case'read':return 2;case'barrier':return 3;case'sampler':return 4;case'effect':return 5;default:return-1}},et=new Set;let tt,rt=1,nt=0,at=0,ot=null;const st=e=>{tt=e},ct=e=>{ot=e},lt=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=e.parent;if(e)return e}return null},dt=(e,t,r,n)=>{const a=lt(e,r.id);return a?a.reg[r.id]:t?(mt(t,r,n),t.reg[r.id]):r};let ut;const ft=e=>{ut=e},pt=e=>e,mt=(e,r,n,a,o)=>{const s=e.reg;if(s[r.id])return;const i=r.sid,c={id:r.id,current:r.initial,meta:r.meta};if(c.id in e.values.idMap)c.current=e.values.idMap[c.id];else if(i&&i in e.values.sidMap&&!(i in e.sidIdMap)){var l;const t=null==r||null===(l=r.meta)||void 0===l?void 0:l.serialize;c.current=(e.fromSerialize&&'ignore'!==t&&(null==t?void 0:t.read)||pt)(e.values.sidMap[i])}else if(r.before&&!o){let o=0;const i=n||!r.noInit||a;t(r.before,(t=>{switch(t.type){case'map':{const r=t.from;if((r||t.fn)&&(r&&mt(e,r,n,a),i)){const e=r&&s[r.id].current;c.current=t.fn?t.fn(e):e}break}case'field':mt(e,t.from,n,a),o||(o=1,c.current=Array.isArray(c.current)?[...c.current]:{...c.current}),i&&(c.current[t.field]=s[s[t.from.id].id].current)}}))}i&&(e.sidIdMap[i]=r.id),s[r.id]=c},gt=(e,t,r)=>{try{return t(W(r),e.scope,r)}catch(t){console.error(t),e.fail=1,e.failReason=t}},ht=(t,r={})=>(Me(t)&&(ht(t.or,r),e(t,((e,t)=>{ze(e)||'or'===t||'and'===t||(r[t]=e)})),ht(t.and,r)),r),yt=(e,t)=>{se(e.next,t),se(V(e),t),se(L(e),t)},vt=['on','reset','sample','split','merge','guard','forward'],bt=(e,t,r,n,a)=>{let o;e.next.length=0,e.seq.length=0,e.scope=null;let s=L(e);const{stateRef:i,defaultShape:c,isRegion:l,op:d}=e.meta;if(i&&(i.before=[],e.meta.stateRef=null),c)for(const e in c)c[e]=null;const u=l?e:n;if(s.length>0){const n=oe(vt,d),i=!l&&!a,c=i&&r&&!n;for(;o=s.pop();){const s=oe(o.next,e);yt(o,e),l&&bt(o,0,0,e,1),s||(o.family.triggers-=1),(t||c||i&&"crosslink"===o.family.type&&!n||a&&oe(vt,o.meta.op)&&(s&&0===o.next.length||!s&&o.family.triggers<=0))&&bt(o,t,r&&'on'!==o.meta.op,u,a)}}for(s=V(e);o=s.pop();)yt(o,e),r&&"crosslink"===o.family.type&&bt(o,t,'on'!==o.meta.op,u,a)},kt=e=>e.clear(),St=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),re(e)){r=1;const t=e.history;kt(t.events),kt(t.effects),kt(t.stores),kt(t.domains)}bt(_(e),!!t,r,null,0)},wt=e=>u((()=>St(e))),$t=(e,t,r,n,o)=>a({node:r,parent:e,child:t,scope:{fn:o},meta:{op:n},family:{owners:[e,t],links:t},regional:1}),Mt=e=>{const t='forward',[{from:r,to:n},o]=d(e,1),s=l(t,o);return ce(0,t,'sample',s),je(r,s,'"from"'),je(n,s,'"to"'),Ce(s,n,'to'),wt(a({parent:r,child:n,meta:{op:t,config:o},family:{},regional:1}))},xt=(e,t)=>(r(xe(t),'.watch argument should be a function'),wt(a({scope:{fn:t},node:[Ee({fn:Oe})],parent:e,meta:{op:'watch'},family:{owners:e},regional:1}))),zt=(e,t,r="event")=>{H(e)&&H(e).hooks[r](t)},Rt=(e,t)=>J(e,'unitTrace',t),At=e=>{const t=Error('unit trace');return Error.captureStackTrace&&Error.captureStackTrace(t,e),t.stack},jt=(e,t,r,n)=>{const a=ht(r),o="domain"===e,s=ue(),{sid:i=null,named:l=null,domain:d=null,parent:u=d}=a,f=l||a.name||(o?'':s),p=c(f,u),m={op:t.kind=e,name:t.shortName=f,sid:t.sid=ke(i),named:l,unitId:t.id=s,serialize:a.serialize,derived:a.derived,config:a,unitTrace:n};if(t.targetable=!a.derived,t.parent=u,t.compositeName=p,t.defaultConfig=a,t.getType=()=>(ce(0,'getType','compositeName.fullName'),p.fullName),!o){t.subscribe=e=>(Re(e),t.watch(xe(e)?e:t=>e.next&&e.next(t))),t[E]=()=>t;const e=be();e&&(m.nativeTemplate=e)}return m},Ct=(e,t,r,n)=>{let a;Me(r)&&(a=r,r=r.fn);const o=p({name:`${e.shortName} \u2192 *`,derived:1,and:a});return $t(e,o,n,t,r),o},Nt='undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option',It=(e,t,r,n,a)=>{const o=B(t),s=De({store:o,to:"a",priority:'read'});r===P&&(s.data.softRead=1);const i=[s,Ve(n)];f('storeOnMap',o,i,Y(e)&&B(e));const c=$t(e,t,i,r,a);return r!==P&&J(c,'onTrigger',_(e).id),c},Ot=(t,n,o,i,c,d,u)=>{const p=l('combine',c),m=t?e=>[...e]:e=>({...e}),h=t?[]:{},y=m(h),v=Be(y),b=Be(1);v.type=t?'list':'shape',v.noInit=1,f('combineBase',v,b);const k=g(y,{name:s(o),derived:1,...u,and:c});Rt(k,i);const S=B(k);S.noInit=1,J(k,'isCombine',1),we(k,[a({meta:{stateRef:v}})]);const w=_e(v);w.order={priority:'barrier'};const $=De({store:S,to:'b',priority:'read'});$.data.softRead=1;const M=[Pe(((e,t,r)=>(r.scope&&!r.scope.reg[v.id]&&(r.c=1),e))),w,De({store:b,to:'b'}),Pe(((e,{key:t},r)=>{if(r.c||e!==r.a[t])return n&&r.b&&(r.a=m(r.a)),r.a[t]=e,1}),1),De({from:"a",target:v}),De({from:"value",store:0,target:b}),De({from:"value",store:1,target:b,priority:'barrier',batch:1}),_e(v,1,1),d&&Ve(),$];if(e(o,((e,t)=>{if(!Y(e))return r(!Q(e)&&!ze(e),`combine expects a store in a field ${t}`,p),void(y[t]=h[t]=e);h[t]=e.defaultState,y[t]=e.getState();const n=$t(e,k,M,'combine',d);n.scope.key=t;const a=B(e);He(v,{type:'field',field:t,from:a}),f('combineField',a,n)})),k.defaultShape=o,J(k,'defaultShape',o),He(S,{type:P,from:v,fn:d}),!be())if(d){const e=d(y);!ze(e)||u&&'skipVoid'in u||console.error(`${p}: ${Nt}`),S.current=e,S.initial=e,k.defaultState=e}else k.defaultState=h;return k},Ft=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},qt=(e,t,r,n,a)=>s=>{o({target:[n,Dt],params:[r?{status:'done',params:e,result:s}:{status:'fail',params:e,error:s},{value:s,fn:r?t.rs:t.rj}],defer:1,page:a.page,scope:a.scope,meta:a.meta})},Dt=a({node:[Ee({fn:({fn:e,value:t})=>e(t)})],meta:{op:'fx',fx:'sidechain'}}),Tt=['source','clock','target'],Et=(e,t)=>e+`: ${t} should be defined`,Pt=(e,t,n,a,o,s,i,c,d,u,m,y)=>{const v=l(e,c),b=!!o;r(!ze(n)||!ze(t),Et(v,'either source or clock'));let k=0;ze(n)?k=1:Q(n)||(n=h(n)),ze(t)?t=n:(je(t,v,'clock'),Array.isArray(t)&&(t=$t(t,[],[],e))),k&&(n=t),c||i||(i=n.shortName),c&&i&&(c.name=i);let S='none';(m||a)&&(Q(a)?S='unit':(r(xe(a),'`filter` should be function or unit'),S='fn')),o?(je(o,v,'target'),Ce(v,o)):'none'===S&&u&&Y(n)&&Y(t)?o=g(s?s(We(B(n)),We(B(t))):We(B(n)),{name:i,sid:y,or:c}):(o=p({name:i,derived:1,or:c}),f('sampleTarget',_(o)));const w=Be();let $=[];if('unit'===S){const[r,n,s]=Vt(a,o,t,w,e);s||$.push(..._t(n)),$.push(..._t(r))}const x=[];if(k)d&&x.push(_e(w,1,1));else{const[r,a,s]=Vt(n,o,t,w,e);s||x.push(..._t(a)),x.push(_e(r,1,d))}const z=$t(t,o,[f('sampleSourceLoader'),De({from:"stack",target:w}),...x,...$,_e(w),'fn'===S&&Ve(((e,t,{a:r})=>a(e,r)),1),s&&Ve(Ne),f('sampleSourceUpward',b)],e,s);return we(n,[z]),Object.assign(z.meta,c,{joint:1,stateRef:w}),Rt(z,At(M)),o},_t=e=>[_e(e),Pe(((e,t,{a:r})=>r),1)],Vt=(e,t,r,n,o)=>{const s=Y(e),i=s?B(e):Be(),c=Be(s);return s||a({parent:e,node:[De({from:"stack",target:i}),De({from:"value",store:1,target:c})],family:{owners:[...new Set([e,t,r].flat())],links:t},meta:{op:o},regional:1}),f('sampleSource',c,i,n),[i,c,s]},Lt=(e,t,r,n)=>{const a=e[t];a&&o({target:a,params:Array.isArray(a)?a.map((()=>r)):r,defer:1,stack:n})},Bt="23.4.0",Wt=e=>!e.node.meta.isCombine||e.parent&&'combine'!==e.parent.node.meta.op,Ht=e=>e;export{j as allSettled,b as attach,St as clearNode,h as combine,k as createApi,S as createDomain,v as createEffect,p as createEvent,a as createNode,g as createStore,D as createWatch,I as fork,Mt as forward,w as fromObservable,x as guard,O as hydrate,ae as is,o as launch,z as merge,R as restore,M as sample,F as scopeBind,q as serialize,he as setGraphInspector,ft as setInspector,i as setStoreName,A as split,Le as step,Bt as version,Se as withFactory,n as withRegion};
//# sourceMappingURL=effector.mjs.map
